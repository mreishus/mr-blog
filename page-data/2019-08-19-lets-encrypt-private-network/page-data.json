{"componentChunkName":"component---src-templates-blog-post-js","path":"/2019-08-19-lets-encrypt-private-network/","result":{"data":{"site":{"siteMetadata":{"title":"MatthewReishus.com"}},"markdownRemark":{"id":"e12e4621-6853-5774-a66d-9f7b24899cbf","excerpt":"Problem Description You have a host name that only exists on a private network. For example,\n“myserver.mydomain.com” resolves to an address like 192.168.x.y…","html":"<h2>Problem Description</h2>\n<p>You have a host name that only exists on a private network. For example,\n<em>“myserver.mydomain.com”</em> resolves to an address like <em>192.168.x.y</em>,\n<em>172.16-31.b.c</em>, or <em>10.a.b.c</em>.  You’d like a free, signed, valid SSL\ncertificate for this host, but you don’t plan on putting this host on the\ninternet.  How do you get a <strong>let’s encrypt</strong> certificate for it?</p>\n<h2>Answer</h2>\n<p>It’s possible using DNS challenges.  I found <a href=\"https://community.letsencrypt.org/t/certificates-for-hosts-on-private-networks/174/35\">instructions for making let’s\nencrypt certificates for private\ndomains</a>.\nSince this is posted in a forum thread, I’m reposting the information just in\ncase something happens to it.  All credit goes to <a href=\"https://community.letsencrypt.org/u/bryanlarsen\">Bryan Larsen on the Let’s\nEncrypt Forums</a>.</p>\n<hr>\n<p>Requirements: </p>\n<ul>\n<li>a domain name (example.com)</li>\n<li>access to the DNS server for example.com</li>\n<li>root access on a publicly accessible server (server.example.com). </li>\n</ul>\n<p>And let’s assume you want to create a certificate for 192.168.7.7 named foo.example.com</p>\n<ul>\n<li>install <code class=\"language-text\">certsling</code> on the server.</li>\n<li>Add an A record to point foo(.example.com) to 192.168.7.7</li>\n<li>Add an NS record to point _acme-challenge.foo(.example.com) to server.example.com</li>\n<li><code class=\"language-text\">sudo socat -T15 udp4-recvfrom:53,reuseaddr,fork tcp:localhost:8053</code> on your server</li>\n<li>open port 53 on your server firewall</li>\n<li><code class=\"language-text\">mkdir myemail@example.com</code></li>\n<li><code class=\"language-text\">cd myemail@example.com</code></li>\n<li><code class=\"language-text\">certsling -s --dns foo.example.com</code> to get certs from the letsencrypt staging server</li>\n<li>When the previous step works, <code class=\"language-text\">rm -rf *</code></li>\n<li><code class=\"language-text\">certsling --dns foo.example.com</code> to get real certs</li>\n</ul>\n<p>Your certs will be in “myemail@example.com/foo.example.com/“!</p>\n<hr>\n<p>This worked perfectly for me.  I was able to copy the -chained.crt and the .key\nfile to my gitlab server, to have a local-only docker container registry using\nSSL without any workarounds.  The only downside being that, it’s a manual\nprocess I will have to repeat every 3 months.</p>","frontmatter":{"title":"let's encrypt certificates for private network addresses (ex: 192.168.1.100)","date":"August 20, 2019","description":null}}},"pageContext":{"slug":"/2019-08-19-lets-encrypt-private-network/","previous":{"fields":{"slug":"/2019-08-19-gitlab-self-signed-docker-registry/"},"frontmatter":{"title":"self-hosted gitlab: adding a docker registry with a self-signed certificate","templateKey":"blog-post"}},"next":{"fields":{"slug":"/2019-10-19-connect-phoenix-channel-in-react-and-typescript/"},"frontmatter":{"title":"Connect to Phoenix channels using React and Typescript","templateKey":"blog-post"}}}}}